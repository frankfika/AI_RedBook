# 谷歌发布的「2025年 AI Agent白皮书」，它是这样写的 .......



![图片](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/640-20250503223204617)











**本文转自微信公众号【AIGC新知】的文章—《谷歌刚刚发布 AI Agent 白皮书，2025 年agent时代已开启》**

**
**

![img](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/300-20250503223204520.png)

**AIGC新知**

分享AI实践，探讨人与AI如何协作 --〉智能体 | 工作流 | 大模型 | AI赋能。

271篇原创内容







------



人类非常擅长复杂的模式识别任务。

他们在得出结论之前经常依赖工具——如书籍、谷歌搜索或计算器——来补充他们的先验知识。

就像人类一样，生成式人工智能模型可以经过训练，使用工具来访问实时信息或建议现实世界的行动。例如，模型可以利用数据库检索工具来访问特定信息，例如客户的购买历史记录，因此它可以生成量身定制的购物推荐。或者，根据用户的查询，模型可以进行各种 API 调用，以向同事发送电子邮件回复或代表您完成财务交易。

为此，模型不仅必须能够访问一组外部工具，还需要能够**以自我指导的方式规划和执行任何任务**。这种推理、逻辑和对外部信息的访问的组合都连接到生成式人工智能模型，调用了代理的概念，或者是超出生成式人工智能模型的独立功能的程序。

![图片](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/640-20250503223204587)

**一、模型**

在智能体的范畴内，模型指的是将被用作智能体流程集中决策制定者的语言模型（LM）。

智能体所使用的模型可以是一个或多个任意规模（小型/大型）的语言模型，这些模型能够遵循基于指令的推理和逻辑框架，如**反应（ReAct）、思维链（Chain-of-Thought）或思维树（Tree-of-Thoughts）**等框架。模型可以是通用型的、多模态的，也可以根据特定智能体架构的需求进行微调。

为了获得最佳的生产效果，应当选用最契合期望的最终应用的模型，并且理想情况下，该模型应已基于与计划在认知架构中使用的工具相关的数据特征进行过训练。

需要注意的是，模型通常不会依据智能体的特定配置设置（即工具选择、编排/推理设置）来进行训练。不过，通过向模型提供展示智能体能力的示例，包括智能体在各种情境下使用特定工具或推理步骤的实例，有可能针对智能体的任务进一步优化该模型。

**
**

**二、工具**

工具可以有多种形式，且复杂程度各异，通常与常见的网络应用程序编程接口（API）方法（如 GET、POST、PATCH 和 DELETE）相契合。例如，某工具可以更新数据库中的客户信息，或者获取天气数据来影响智能体向用户提供的旅行建议。

借助工具，智能体能够访问并处理现实世界的信息。这使其能够支持更专业化的系统，比如检索增强生成（RAG），该系统极大地拓展了智能体的能力，使其超越了基础模型自身所能达成的水平。

**
**

**三、agent与模型区别**

| 模型                                                         | 智能体                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 知识局限于训练数据中现有的内容。                             | 通过工具与外部系统连接来扩展知识。                           |
| 基于用户查询进行单次推理 / 预测。除非为模型明确实现，否则不存在会话历史或连续上下文（即聊天历史）的管理。 | 管理会话历史（即聊天历史）以基于编排层中做出的用户查询和决策进行多轮推理 / 预测。在这种情况下，“轮次” 被定义为交互系统与智能体之间的一次交互（即 1 个传入事件 / 查询和 1 个智能体响应）。 |
| 没有原生工具实现。                                           | 工具在智能体架构中是原生实现的。                             |
| 没有实现原生逻辑层。用户可以将提示表述为简单问题，或使用推理框架（CoT、ReAct 等）形成复杂提示来引导模型进行预测。 | 原生认知架构使用推理框架（如 CoT、ReAct）或其他预构建的智能体框架（如 LangChain）。 |

**
**

**四、常见的提示工程框架**

反射（ReAct），为语言模型提供一种思考过程策略，使其能够对用户查询进行推理并采取行动，无论是否有上下文示例。ReAct提示已被证明优于一些最先进的（SOTA）基准，并且提高了大型语言模型（LLMs）的人机交互性和可信度。

![图片](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/640-20250503223204573)

思维链（Chain - of - Thought，CoT），通过中间步骤实现推理能力。CoT有多种子技术，包括自洽性、主动提示和多模态CoT，根据具体应用的不同，它们各有优缺点。思维树（Tree - of - thoughts，ToT），非常适合探索或策略性前瞻任务。它是对思维链提示的概括，允许模型探索各种思维链，这些思维链作为使用语言模型解决一般问题的中间步骤。

**
**

**五、扩展：自定义插件**

理解扩展（Extensions）最简单的方法是把它们看作是以一种标准化的方式在应用程序编程接口（API）和智能体之间架起桥梁，让智能体能够无缝地执行各种API，而无需考虑其底层实现方式。



![图片](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/640-20250503223204555-6282724.)

agent如何与外部 API 交互？

假设你构建了一个智能体，其目标是帮助用户预订航班。你知道你想要使用谷歌航班API来获取航班信息，但你不确定如何让你的智能体调用这个API端点。

一种更具适应性的方法是使用扩展。扩展通过以下方式在智能体和应用程序编程接口（API）之间架起桥梁： 1. 通过示例来教导智能体如何使用API端点。 2. 教导智能体成功调用API端点需要哪些参数。

![图片](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/640-20250503223204594)

扩展可以独立于智能体进行构建，但应作为智能体配置的一部分来提供。智能体在运行时利用模型和示例来决定哪一个（如果有的话）扩展适合用于解决用户的查询。这凸显了扩展的一个关键优势，即它们的“内置示例类型”，这使得智能体能够针对任务动态地选择最合适的扩展。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/zvStibNiazLDI0qSfbwKfY85nHWUeRzff79eCHakp1Gial4H79bkQhLxrlH2liaWHGqlmrOtG9q0LSH9WfMBa1zVCA/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1)

**
**

**
**

**六、功能函数**

在智能体领域中，函数的工作方式与之非常相似，不过我们可以用模型来替代软件开发人员。模型能够获取一组已知函数，并根据函数的规范来决定何时使用每个函数以及该函数需要哪些参数。

![图片](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/640-20250503223204549)

函数与扩展在几个方面存在差异，最显著的差异如下： 1. 模型会输出一个函数及其参数，但不会进行实时的应用程序编程接口（API）调用。 2. 函数在客户端执行，而扩展则在智能体端执行。

大多数开发人员常用功能函数，原因在于：

- 应用程序栈的另一层需要进行应用程序编程接口（API）调用，这处于直接的智能体架构流程之外（例如中间件系统、前端框架等）
- 存在安全或认证方面的限制，导致智能体无法直接调用 API（例如 API 未暴露在互联网上，或者智能体基础设施无法访问该 API）
- 存在时间安排或操作顺序方面的限制，使得智能体无法实时进行 API 调用（即批量操作、人工介入审查等情况）。
- 需要对智能体无法执行的应用程序编程接口（API）响应应用额外的数据转换逻辑。例如，设想有一个API端点，它并未提供用于限制返回结果数量的筛选机制。在客户端使用函数可为开发人员提供进行这些转换的额外机会。
- 开发人员希望在智能体开发过程中进行迭代，而无需为API端点部署额外的基础设施（即函数调用可以起到对API进行“存根”的作用）。 

![图片](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/640-20250503223204555)

描述扩展和函数调用的客户端与代理端控制

**
**

**七、数据存储**

数据存储允许开发人员以原始格式向智能体提供额外的数据，从而无需进行耗时的数据转换、模型重新训练或微调工作。

数据存储会将传入的文档转换为一组向量数据库嵌入，智能体可利用这些嵌入提取所需信息，以辅助其下一步行动或对用户的回复。 

![图片](./%E8%B0%B7%E6%AD%8C%E5%8F%91%E5%B8%83%E7%9A%84%E3%80%8C2025%E5%B9%B4%20AI%20Agent%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%8D%EF%BC%8C%E5%AE%83%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%20........assets/640-20250503223204597)

为了帮助模型获取特定类型的知识，存在以下几种方法： • 上下文内学习：在推理时为通用模型提供提示、工具和少量示例，使其能够“即时”学习针对特定任务如何以及何时使用这些工具。反应（ReAct）框架就是这种在自然语言处理中的方法示例。 • 基于检索的上下文内学习：通过从外部存储器中检索最相关的信息、工具和相关示例，来动态填充模型提示。例如Vertex AI扩展中的“示例存储”或者前文提到的基于数据存储的检索增强生成（RAG）架构。 • 基于微调的学习：涉及在推理之前使用包含大量特定示例的数据集对模型进行训练。这有助于模型在接收任何用户查询之前就了解何时以及如何应用某些工具。



总结回顾：

|          | **扩展**                                                     | **函数调用**                                                 | **数据存储**                                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 执行     | 智能体端执行（Agent - Side Execution）                       | 客户端执行（Client - Side Execution）                        | 智能体端执行（Agent - Side Execution）                       |
| 使用案例 | - 开发者希望智能体控制与 API 端点的交互。- 在利用本地预构建扩展（例如 Vertex Search、代码解释器等）时很有用。- 多跳规划和 API 调用（即下一个智能体动作取决于之前动作 / API 调用的结果） | - 安全或认证限制阻止智能体直接调用 API。- 时间限制或操作顺序限制阻止智能体实时进行 API 调用。- 未暴露在互联网上或谷歌系统无法访问的 API。 | - 开发者希望使用以下任何数据类型实现检索增强生成（RAG）：- 来自预索引域和 URL 的网站内容。- 以 PDF、Word 文档、CSV、电子表格等格式存在的结构化数据。- 以 HTML、PDF、TXT 等格式存在的非关系型 / 非结构化数据。 |



